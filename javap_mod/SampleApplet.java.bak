import java.applet.Applet;
import java.awt.*;
import java.awt.event.*;

public class SampleApplet extends Applet implements Runnable, KeyListener {
	Image img;
	Image img_m;

	int width = 640, height = 480; //★bufferの幅と高さ
	int x=270;	//描画したい画像のｘ座標の初期値
	int y=380;	//描画したい画像のｙ座標の初期値
	int x2=270;
	int y2=0;
	int HP = 5, HP2 = 5; //1P,2Pの体力

	Thread gameThread;
	private Image offImage; //★buffer用イメージ
	boolean tama_flag[]; ////弾フラグ２
	boolean tama2_flag[];	//弾フラグ２
	boolean atari_flag[]; //敵フラグ(１から２にあたったかどうか）
	boolean atari2_flag[]; //敵フラグ２（２から１あたったかどうか）
	int tama_x[], tama_y[]; //tama x,y
	int tama2_x[], tama2_y[]; //tama x2,y2
	int tama_x_c[], tama2_x_c[]; //弾を発射してからx座標が動かない用にする
	boolean syouhai_flag = false; //勝敗を確認
	boolean syouhai2_flag = false; //勝敗を確認

	public class Constants {
		public static final int XM = 10;
		public static final int YM = 10;
		public static final int XM2 = 10;
		public static final int YM2 = 10;
		public static final	int tamakazu = 10 + 1; //一度に発射できる弾の数
	}

	int ii = 0; //1Pの配列中の何番目の弾を処理するか

	int ii2 = 0; //2Pの配列の何番目の弾を発射するか
	public void init(){
		//init とは、「初期化(initialize)」

		tama_flag = new boolean [Constants.tamakazu];
		tama2_flag = new boolean [Constants.tamakazu];
		atari_flag = new boolean [Constants.tamakazu];
		atari2_flag = new boolean [Constants.tamakazu];
		tama_x = new int[Constants.tamakazu];
		tama_y = new int [Constants.tamakazu];
		tama2_x = new int [Constants.tamakazu];
		tama2_y = new int [Constants.tamakazu];
		tama_x_c = new int [Constants.tamakazu];
		tama2_x_c = new int [Constants.tamakazu];

		img = getImage(getDocumentBase(),"Sample_m.png"); //読み込んだ画像
		img_m = getImage(getDocumentBase(), "sample_m.png");
		offImage = createImage(width, height); //★bufferを作成
		setBackground(Color.green); //★ついでにバックグラウンドを白にした
		addKeyListener(this); //●追加

		for (int j = 0; j < Constants.tamakazu; ++j) {
			tama_x[j] = x; //初期化：配列を全部０埋めしている//弾のｘ座標はキャラと同じ
			tama_y[j] = y; //初期化：配列を全部０埋めしている//弾のｙ座標はキャラと同じ
			tama2_x[j] = x2;
			tama2_y[j] = y2;
			tama_flag[j] = false; //初期化：配列を全部falseにしている//発射フラグ初期設定
			tama2_flag[j] = false; //発射フラグ初期設定
			tama_x_c[j] = x;
			tama2_x_c[j] = y;
			atari_flag[j] = false;
			atari2_flag[j] = false;
		}
	}

	public void paint(Graphics g){
		Graphics gv = offImage.getGraphics(); //★buffer用
		gv.clearRect(0,0,width,height); //★バッファ領域をクリアする


		//paint とは、ペイント(描画)という意味
		gv.drawImage(img_m,x,y,this);
		gv.drawImage(img,x2,y2,this);

		//gv.setColor(Color.green);	//緑

		gv.setColor(Color.blue);	//青
		//gv.drawRect(x,y,100,100);	//四角形
		//gv.drawRect(x2,y2,100,100);
		//gv.drawLine(0,250,300,250);	//線
		//gv.drawLine(0,240,540,240);

		//gv.drawRect(0,50,300,200);	//長方形

		//gv.drawOval(350,250,100,200);	//楕円

		//gv.fillOval(x + 25,y - 50,50,50);	//塗りつぶし円
		//gv.fillOval(x2 + 25,y2 - 50,50,50);	//塗りつぶし円その２

		gv.setColor(Color.black);  //弾の色をくろ
		for (int j = 0; j < Constants.tamakazu; ++j) {
			gv.fillOval(tama_x[j] + 55,tama_y[j] + 34,16,17); //弾を表示
			gv.fillOval(x2 + 55,tama2_y[j] + 34,16,17); //弾2を表示
		}

		//gv.drawString("X  :("+x+")",5,10);	//画像のx座標を(5,10)に表示
		//gv.drawString("Y  :("+y+")",55,10); 	//画像のy座標を(55,10)に表示
		//gv.drawString("X2:("+x2+")",5,23);	//画像のx座標を(5,23)に表示
		//gv.drawString("Y2:("+y2+")",55,23); 	//画像のy座標を(55,23)に表示
		gv.drawString("1P弾数:("+(Constants.tamakazu - ii - 1)+")",5,10);	//1Pの弾数を表示
		gv.drawString("HP  :("+HP+")",70,10);	//HPを表示
		gv.drawString("2P弾数:("+(Constants.tamakazu - ii2 - 1)+")",5,23);	//P2の弾数を表示
		gv.drawString("HP2:("+HP2+")",70,23);	//HP2を表示

		if ((syouhai_flag == true) && (syouhai2_flag == false)) {
			gv.drawString("1PWIN!",270,240);
		}
		if ((syouhai2_flag == true) && (syouhai_flag == false)) {
			gv.drawString("2PWIN!",270,240);
		}
		if ((syouhai2_flag == true) && (syouhai_flag == true)) {
			gv.drawString("drawn!", 270,240);
		}

		g.drawImage(offImage,0,0,width,height,this); //最後にbufferから
		//完成領域に表示する

		requestFocusInWindow(); //←重要 フォーカスをアップレットウィンドウにしないといけない
	}

	public void update(Graphics g) { //アップデート(画像の再描画)用の関数
		paint(g);
	}

	public void start() { //start関数は、ゲームスレッドを作って、スタートさせる
		gameThread = new Thread(this);
		gameThread.start();
		gameThread = null;
	}

	public void keyPressed(KeyEvent e) {

			switch(e.getKeyCode()) {
				case KeyEvent.VK_RIGHT: //「→」キーを入力したとき
					//++x; //右へ移動
					if (x < width - 100) {
						x += Constants.XM; //５倍速
						for (int i = 0; i < Constants.tamakazu; i++) {
							if (tama_flag[i] == false) {
									tama_x[i] += Constants.XM;
							}
						}
					}
					break;
				case KeyEvent.VK_LEFT: //「←」キーを入力したとき
					//--x; //左へ移動
					if (x > 0) {
						x -= Constants.XM;
						for (int i = 0; i < Constants.tamakazu; i++) {
							if (tama_flag[i] == false) {
								tama_x[i] -= Constants.XM;
							}
						}
					}
					break;
				case KeyEvent.VK_UP: //「↑」キーを入力したとき
					//--y; //上へ移動
					if (y > 0) {
						y -= Constants.YM;
						for (int i = 0; i < Constants.tamakazu; i++) {
							if (tama_flag[i] == false) {
								tama_y[i] -= Constants.YM;
							}
						}
					}
					break;
				case KeyEvent.VK_DOWN: //「↓」キーを入力したとき
					//++y; //下へ移動
					if (y < height - 100) {
						y += Constants.YM;
						for (int i = 0; i < Constants.tamakazu; i++) {
							if (tama_flag[i] == false) {
								tama_y[i] += Constants.YM;
							}
						}
					}
					break;
				default: //case分に書いていないイベントが発生したときは何もしない
					break;
			}

			switch(e.getKeyCode()) {
				case KeyEvent.VK_D: //「C」キーを入力したとき
					//++x; //右へ移動
					if (x2 < width - 100) {
						x2 += Constants.XM2; //５倍速
						for (int i = 0; i < Constants.tamakazu; i++) {
							if (tama2_flag[i] == false) {
								tama2_x[i] += Constants.XM2;
							}
						}
					}
					break;
				case KeyEvent.VK_A: //「Z」キーを入力したとき
					//--x; //左へ移動
					if (x2 > 0) {
						x2 -= Constants.XM2;
						for (int i = 0; i < Constants.tamakazu; i++) {
							if (tama2_flag[i] == false) {
								tama2_x[i] -= Constants.XM2;
							}
						}
					}
					break;
				case KeyEvent.VK_W: //「S」キーを入力したとき
					//--y; //上へ移動
					if (y2 > 0) {
						y2 -= Constants.YM2;
						for (int i = 0; i < Constants.tamakazu; i++) {
							if (tama2_flag[i] == false) {
								tama2_y[i] -= Constants.YM2;
							}
						}
					}
					break;
				case KeyEvent.VK_S: //「X」キーを入力したとき
					//++y; //下へ移動
					if (y2 < height - 100) {
						y2 += Constants.YM2;
						for (int i = 0; i < Constants.tamakazu; i++) {
							if (tama2_flag[i] == false) {
								tama2_y[i] += Constants.YM2;
							}
						}
					}
					break;
				default: //case分に書いていないイベントが発生したときは何もしない
					break;
			}

			switch(e.getKeyCode()) { //1P
				case KeyEvent.VK_SPACE: //space キーを押したときに
					if (tama2_flag[ii] == false) {
					 	tama2_flag[ii] = true; //弾発射フラグをturueにする
						ii = ii + 1;//次の弾を見る
						tama2_x_c[ii] = tama2_x[ii];//弾のｘ座標を固定する
					}
					break;
			}

			switch(e.getKeyCode()) { //2P
				case KeyEvent.VK_ENTER: //enter キーを押したときに
					if (tama_flag[ii2] == false) {
				 		tama_flag[ii2] = true; //弾発射フラグをturueにする
						ii2 = ii2 + 1;
						tama_x_c[ii2] = tama_x[ii2];
					}
					break;
				}
			}

	public void keyReleased(KeyEvent e) {/*中身は空*/} //ボタンを離したとき用の関数
	public void keyTyped(KeyEvent e) {/*中身は空*/} //キーを入力した時用の関数

	public void run(){ //run関数は、run(実行)部分
		//ここに、座標計算などの処理を書く
		boolean flag = true;
		while (true) { //while(true)とは無限ループせよという意味
			for (int i = 0; i < Constants.tamakazu; ++i) {
				if (tama_flag[i] == true) { //弾フラグがtrue(enterキーが押された)なら、弾を上へ移動
					if (Constants.tamakazu == ii2) { //ゲームの終了条件
						try {	//待ち
							Thread.sleep(500);
						}
						catch (InterruptedException e) {
						}
						x = 10000;
						y = 10000;
						tama_x[i] = 10000;
						tama_y[i] = 10000;
						syouhai_flag = true;
					}
					tama_y[i] -= 5;//弾を移動
					tama_x[i] = tama_x_c[i];//弾の誤移動を防止
					if (tama_y[i] == y2) {//敵に当たったかの判定
						if ((x2 - 58 <= tama_x[i] + 8) && (tama_x[i] + 8 <= x2 + 42)) {
								atari_flag[i] = true;
						}
					}
					if (tama_y[i] <= (-50)) { //弾のyが(-50)を下回ったらキャラの位置に戻す
						tama_flag[i] = false;
						tama_x[i] = x;
						tama_y[i] = y;
					}
					if (atari_flag[i] == true) {//敵に当たったときの処理
						HP2 -= 1;
						tama_x[i] = x;
						tama_y[i] = y;
						tama_flag[i] = false;
						atari_flag[i] = false;
						if (HP2 == 0){//ゲームの終了条件
							x2 = 10000;
							y2 = 10000;
							tama2_x[i] = 10000;
							tama2_y[i] = 10000;
						}
					}
				}
//				if (tama_flag[i] == false) {//ここにtama_flagがfalseのときの処理を入れる
//
//				}
			}
			for (int i2 = 0; i2 < Constants.tamakazu; ++i2) {
				if (tama2_flag[i2] == true) { //弾フラグがtrue(spaceキーが押された)なら、弾を上へ移動
					if (Constants.tamakazu == ii) {//ゲーム終了条件
						try {	//待ち
							Thread.sleep(500);
						}
						catch (InterruptedException e) {
						}
						x2= 10000;
						y2 = 10000;
						tama_x[i2] = 10000;
						tama_y[i2] = 10000;
						syouhai2_flag = true;
					}
					tama2_y[i2] += 5;
					tama2_x[i2] = tama2_x_c[i2];
					if (tama2_y[i2] == y) {
						if ((x - 58 <= tama2_x[i2] + 8) && (tama2_x[i2] + 8 <= x + 42)) {
								atari2_flag[i2] = true;
						}
					}
					if (tama2_y[i2] >= height) { //弾のyがheightを上回ったらキャラの位置に戻す
						tama2_flag[i2] = false;
						tama2_x[i2] = x2;
						tama2_y[i2] = y2;
					}
					if (atari2_flag[i2] == true) {
						HP -= 1;
						tama2_x[i2] = x2;
						tama2_y[i2] = y2;
						tama2_flag[i2] = false;
						atari2_flag[i2] = false;
						if ((HP == 0)) {//ゲーム終了条件
							x = 10000;
							y = 10000;
							tama_x[i2] = 10000;
							tama_y[i2] = 10000;
						}
					}
				}
			}

			if (HP == 0) {
				syouhai_flag = true;
			}
			if (HP2 == 0) {
				syouhai2_flag = true;
			}

/*			if (flag == true) {	// x座標が540以下なら
				x += 2;	//x座標に1ずつ足せ
				++y;
				x2 += 2;
				--y2;
			}	//if 文の括弧の終わり
			if (x == 500) {
				flag = false;
			}
			if (flag == false) {
				x -= 2;
				--y;
				x2 -= 2;
				++y2;
			}
			if (x == 0) {
				flag = true;
			}
*/			repaint();	//その都度、再描画(paint関数を呼べ)せよ
			try {	//try 文とは、エラーを起こすかもしれない処理をtry(試せ)という意味
				Thread.sleep(5);
			}	//try 文の括弧の終わり
			catch (InterruptedException e) {	//catch 文とは、try文で出たエラーを補足(catch)せよという意味
			}	//catch 文の括弧の終わり
		}	//while 文の括弧の終わり
	}
}
